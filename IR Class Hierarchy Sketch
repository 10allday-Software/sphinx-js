Node:
    .name (the short name of a member, regardless of whether it's a class or function or typedef or param)
    .description
    .path_segments (computed from .longname) (our namepath-like things)
    .path (computed from path_segments)
    .filename ("foo.js", computed from fs_path)
    .fs_path (full OS-specific pathname with extension)
    .line (from .lineno)
    .deprecated
    .examples
    .memberof  # Or maybe Class.members suffices.
    .see_also
    .properties



# Top-level entities. You can look these up by path.

Class or Function:  # Whether this ends up being a common superclass is an implementation detail, but the point is that both functions and classes have these fields.
    .params (classes in TS are type-parametrizable)

Function(Node):
    .exceptions
    .returns

Class(Node):
    (.classdesc can go into Node.description)
    Maybe _sphinxjs_doclets_by_class turns into .members.
    Maybe will want a .constructor.

Typedef(Node?):  # TODO: Make sure autofunction still works on these.
    .type



Anything that can be a class member (constant, (function, class, attr, anything else?):
    .access (private, public, protected)

# Subentities:

Param:  # Does this subclass Node? It has a name, description, filename, lineno. Probably. But no, it doesn't have path_segments or much of the other stuff.
    .name
    .description
    .default
    .is_variadic
    .types # list of type, which are strings. Types could even be parametrized by other types, but we probably don't care for IR purposes: let whichever analyzer boil them down to strings.

Property:
    .name
    .types
    .description

Exception:
    .types
    .description

Return:
    .types
    .description


Unneeded in and of themselves:
    .meta.path (just to implement doclet_full_path)
    .kind (function vs. typedef. Can be represented by node class.)




SOURCES OF THOSE THINGS:
    To implement doclet_full_path:
        d.meta.path
        d.meta.filename without extension
        d.longname
        d.memberof
    Renderers:
        For error reporting:
            d.meta.filename
            d.longname
            d.meta.lineno
        For formal params:
            d.params
            param.defaultvalue
            param.type
                # Could be an array of types. Types could even be parametrized by other types, but we probably don't care for the IR: let the analyzer boil them down to strings.
            param.is_variadic
        For _fields:
            d.params
            d.properties
            d.exceptions
            d.returns
        For functions:
            d.description
            d.examples
            d.deprecated
            d.see_also
        For classes:
            …some stuff we've already seen and…
            d.classdesc
            d.kind (function vs. typedef)
            d.name (the short name of a member, regardless of whether it's a class of function)
            d.access (private, public, protected)
