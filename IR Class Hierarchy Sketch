TopLevel:
    .name (the short name of a member, regardless of whether it's a class or function or typedef or param)
    .description
    .path_segments (computed from .longname) (our namepath-like things)
    .path (joined path_segments)  # might not need. Nope, need it for doclets_to_include(). Nm, I switched it to use path_segments. It's just for sorting.
    .filename ("foo.js", computed from fs_path)
    #.fs_path (full OS-specific pathname with extension)
    .line (from .lineno)
    .deprecated
    .examples
    .memberof  # Or maybe Class.members suffices.
    .see_alsos
    .properties
    .is_private



# Top-level entities. You can look these up by path.

Class or Function:  # Whether this ends up being a common superclass is an implementation detail, but the point is that both functions and classes have these fields.
    .params (classes in TS are type-parametrizable)

Function(TopLevel):
    .exceptions
    .returns

Class(TopLevel):
    (.classdesc goes into TopLevel.description)
    .constructor_description
    Maybe _sphinxjs_doclets_by_class turns into .members.
    Maybe will want a .constructor.

#Typedef(TopLevel?):  # TODO: Make sure autofunction still works on these.
#    .type  # Yeah, so, we're using Functions to represent Typedefs as well, because apparently we were doing it before. Let's see how it works out. Maybe stop doing that once we show everything is working, because it's icky.

Attribute(TopLevel):
    .types


Anything that can be a class member (functions, attributes. That's all we need, because it's all jsdoc.doclets_as_class emits.):
    .access (private, public, protected)

# Subentities:

Param:  # Does this subclass TopLevel? It has a name, description, filename, lineno. Probably. But no, it doesn't have path_segments or much of the other stuff.
    .name
    .description
    .default
    .is_variadic
    .types # list of types, which are strings. Types could even be parametrized by other types, but we probably don't care for IR purposes: let whichever analyzer boil them down to strings.

Property:
    .name
    .types
    .description

Exception:
    .types
    .description

Return:
    .types
    .description


Unneeded in and of themselves:
    .meta.path (just to implement doclet_full_path)
    .kind (function vs. typedef. Can be represented by node class.)




SOURCES OF THOSE THINGS:
    To implement doclet_full_path:
        d.meta.path
        d.meta.filename without extension
        d.longname
        d.memberof
    Renderers:
        For error reporting:
            d.meta.filename
            d.longname
            d.meta.lineno
        For formal params:
            d.params
            param.defaultvalue
            param.type
                # Could be an array of types. Types could even be parametrized by other types, but we probably don't care for the IR: let the analyzer boil them down to strings.
            param.is_variadic
        For _fields:
            d.params
            d.properties
            d.exceptions
            d.returns
        For functions:
            d.description
            d.examples
            d.deprecated
            d.see_also
        For classes:
            …some stuff we've already seen and…
            d.classdesc
            d.kind (function vs. typedef)
            d.name (the short name of a member, regardless of whether it's a class of function)
            d.access (private, public, protected)
